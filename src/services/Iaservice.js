const fetch = require("node-fetch");
require("dotenv").config();

// Cache em mem√≥ria com tempo de vida
const responseCache = new Map();
const CACHE_DURATION = 10 * 60 * 1000; // 10 minutos

// Tempo m√°ximo de espera para APIs
const API_TIMEOUT = 8000; // 8 segundos

// Vari√°vel para manter o contexto da conversa
let contextoConversa = {
  ultimoLivroMencionado: null,
  ultimaPergunta: null
};

let piadasAnteriores = [];

async function perguntarIA(pergunta, livrosDisponiveis = []) {
  // Verifica√ß√£o b√°sica dos dados
  if (!pergunta || typeof pergunta !== "string" || pergunta.trim().length < 2) {
    return "Por favor, fa√ßa uma pergunta v√°lida com pelo menos 2 caracteres.";
  }

  // Pr√©-processamento da pergunta
  const perguntaLower = pergunta.toLowerCase().trim();
  
  // Atualiza o contexto da conversa
  contextoConversa.ultimaPergunta = perguntaLower;

  // Verifica se √© um cumprimento ou intera√ß√£o social (tratamento especial)
  if (isInteracaoSocial(perguntaLower)) {
    return gerarRespostaSocial(perguntaLower);
  }

  if (perguntaLower.includes("piada") || perguntaLower.includes("conte uma piada")) {
    return contarPiadaLiteraria();
  }

  // Verifica se √© pedido de outra piada
  if (perguntaLower.includes("outra piada") || perguntaLower.includes("mais uma piada")) {
    return responderOutraPiada();
  }

  // Verifica se √© um pedido de curiosidade
  if (perguntaLower.includes("curiosidade") || perguntaLower.includes("fato interessante")) {
    return contarCuriosidadeLiteraria();
  }

  // Verifica se √© um pedido de formatos dispon√≠veis
  if (perguntaLower.includes("formatos") || perguntaLower.includes("dispon√≠vel") || perguntaLower.includes("vers√£o")) {
    const livroEncontrado = contextoConversa.ultimoLivroMencionado || findBook(perguntaLower, livrosDisponiveis);
    if (livroEncontrado) {
      return generateFormatsResponse(livroEncontrado);
    }
  }

  // Verifica se √© pedido de livros dispon√≠veis
  if (perguntaLower.includes("livros dispon√≠veis") || perguntaLower.includes("livros disponiveis")) {
    return listarLivrosDisponiveis(livrosDisponiveis);
  }

  // Verifica√ß√£o espec√≠fica para perguntas sobre autores/livros
  if (perguntaLower.includes("de que autor") || 
      perguntaLower.includes("quem escreveu") || 
      perguntaLower.includes("de quem") || 
      perguntaLower.includes("de quem √©")) {
    const livroEncontrado = findBook(perguntaLower, livrosDisponiveis);
    if (livroEncontrado) {
      contextoConversa.ultimoLivroMencionado = livroEncontrado;
      return generateBookFoundResponse(livroEncontrado);
    }
    return "üìö N√£o encontrei esse livro em nosso acervo. Deseja ver outros livros dispon√≠veis?";
  }

  // Verifica se √© pedido de recomenda√ß√µes
  if (perguntaLower.includes("recomenda√ß√µes") || perguntaLower.includes("recomendar") || perguntaLower.includes("sugest√µes")) {
    return generateBookRecommendation(livrosDisponiveis);
  }

  // Verifica cache primeiro
  const cacheKey = generateCacheKey(pergunta, livrosDisponiveis);
  const cachedResponse = getFromCache(cacheKey);
  if (cachedResponse) return cachedResponse;

  // Tenta diferentes estrat√©gias em ordem
  try {
    // 1. Tentativa com Hugging Face
    const resposta = await tryWithTimeout(
      () => callHuggingFaceAPI(pergunta, livrosDisponiveis),
      API_TIMEOUT
    );
    saveToCache(cacheKey, resposta);
    
    // Atualiza contexto se encontrar um livro na resposta
    const livroEncontrado = findBook(perguntaLower, livrosDisponiveis);
    if (livroEncontrado) {
      contextoConversa.ultimoLivroMencionado = livroEncontrado;
    }
    
    return resposta;
  } catch (error) {
    console.error("Erro na API Hugging Face:", {
      message: error.message,
      status: error.response?.status,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }

  try {
    // 2. Tentativa com Together.ai
    const resposta = await tryWithTimeout(
      () => callTogetherAPI(pergunta, livrosDisponiveis),
      API_TIMEOUT
    );
    saveToCache(cacheKey, resposta);
    
    // Atualiza contexto se encontrar um livro na resposta
    const livroEncontrado = findBook(perguntaLower, livrosDisponiveis);
    if (livroEncontrado) {
      contextoConversa.ultimoLivroMencionado = livroEncontrado;
    }
    
    return resposta;
  } catch (error) {
    console.error("Erro na API Together.ai:", {
      message: error.message,
      status: error.response?.status,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }

  try {
    // 3. Tentativa com modelo local via Ollama (se configurado)
    if (process.env.OLLAMA_ENABLED === "true") {
      const resposta = await tryWithTimeout(
        () => callOllamaAPI(pergunta, livrosDisponiveis),
        API_TIMEOUT
      );
      saveToCache(cacheKey, resposta);
      
      // Atualiza contexto se encontrar um livro na resposta
      const livroEncontrado = findBook(perguntaLower, livrosDisponiveis);
      if (livroEncontrado) {
        contextoConversa.ultimoLivroMencionado = livroEncontrado;
      }
      
      return resposta;
    }
  } catch (error) {
    console.error("Erro no Ollama:", {
      message: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }

  // 4. Fallback local completo
  const respostaLocal = generateLocalResponse(perguntaLower, livrosDisponiveis);
  
  // Atualiza contexto se encontrar um livro na resposta
  const livroEncontrado = findBook(perguntaLower, livrosDisponiveis);
  if (livroEncontrado) {
    contextoConversa.ultimoLivroMencionado = livroEncontrado;
  }
  
  return respostaLocal;
}

// --- Fun√ß√µes para intera√ß√µes comuns --- //

function contarPiadaLiteraria() {
  const piadasDisponiveis = [
"üìñ Por que o livro de matem√°tica ficou deprimido? Porque tinha muitos problemas!",
"üòÇ O que o l√°pis disse para o papel? 'Voc√™ est√° me desapontando!'",
"üìö Por que o livro foi preso? Porque tinha muitas p√°ginas em branco - era um caso de folhas em branco!",
"ü§ì Sabia que os livros de suspense s√£o √≥timos para emagrecer? D√£o um susto que at√© o apetite some!",
"üòÑ Qual √© o animal mais antigo do mundo? O vaga-lume, porque est√° no livro das recorda√ß√µes!",
"üìñ Um jovem autor queria escrever para o mundo todo. Provocar rea√ß√µes de emo√ß√£o, l√°grimas e fazer seus leitores perderem o sono. Ele virou redator das mensagens de erro do Windows.",
"üòÇ O que o livro de gram√°tica disse para o livro de hist√≥ria? 'Voc√™ vive no passado!'",
"üìö Qual √© o livro mais doce que existe? O Romeu e Julieta!",
"üìñ John Green teve um pesadelo em que ele era perseguido por um peda√ßo de madeira falante. Qual √© o nome do livro? ‚ÄúQuem √© voc√™? A Lasca‚Äù",
"üòÇ O que o livro de ci√™ncias disse para o livro de geografia? 'Voc√™ est√° sempre viajando!'",
"üìö O que o marcador de p√°gina disse para o livro? 'Eu te sigo at√© o fim!'",
"ü§ì Como o livro de f√≠sica se exercita? Com muitas p√°ginas de for√ßa!",
"üòÑ Paulo Coelho come feij√£o com curry; a Paula Pimenta.",
"üìñ Casamento √© tipo Machado de Assis: come√ßa no romantismo, mas logo acaba no realismo.  ",
"üòÇ Voc√™ tem algum √≥rg√£o transplantado? O Frankenstein."
  ];

  // Filtra piadas que ainda n√£o foram usadas
  let piadasNaoUsadas = piadasDisponiveis.filter(piada => 
    !piadasAnteriores.includes(piada)
  );

  // Se todas j√° foram usadas, reinicia o ciclo
  if (piadasNaoUsadas.length === 0) {
    piadasAnteriores = [];
    piadasNaoUsadas = [...piadasDisponiveis];
  }

  // Seleciona uma piada aleat√≥ria
  const piadaAleatoria = piadasNaoUsadas[
    Math.floor(Math.random() * piadasNaoUsadas.length)
  ];

  // Adiciona a piada usada ao hist√≥rico
  piadasAnteriores.push(piadaAleatoria);

  return piadaAleatoria;
}

function responderOutraPiada() {
  return contarPiadaLiteraria();
}

function contarCuriosidadeLiteraria() {
  const curiosidades = [
    "üìö Sabia que o livro mais roubado de bibliotecas p√∫blicas √© o Guinness World Records?",
    "üñãÔ∏è A palavra 'livro' vem do latim 'liber', que originalmente significava a camada interna da casca das √°rvores!",
    "üìñ O maior livro do mundo √© 'O Pequeno Pr√≠ncipe', que foi traduzido para mais de 300 l√≠nguas e dialetos!",
    "‚úçÔ∏è Machado de Assis, nosso grande escritor brasileiro, era canhoto e sofria de epilepsia!",
    "üìï O livro mais vendido da hist√≥ria (depois da B√≠blia) √© 'Dom Quixote', de Miguel de Cervantes!",
    "üîç A Biblioteca do Congresso dos EUA √© a maior do mundo, com mais de 170 milh√µes de itens!",
    "üìñ O termo 'bookworm' (tra√ßa de livros) vem dos insetos que comem papel, mas tamb√©m se refere a pessoas que leem muito!",
    "‚úâÔ∏è J.R.R. Tolkien recebeu tantas cartas de f√£s endere√ßadas a 'Frodo, O Condado' que teve que deixar de responder!"
  ];
  return curiosidades[Math.floor(Math.random() * curiosidades.length)];
}

function generateFormatsResponse(livro) {
  let resposta = `üìö Formatos dispon√≠veis para "${formatarTitulo(livro.titulo)}":\n\n`;
  
  resposta += `üì± E-book: ${livro.id_ebook ? "Sim" : "N√£o"}\n\n`;
  resposta += `üéß Audiobook: ${livro.id_Audiobook ? "Sim" : "N√£o"}\n\n`;
  resposta += `üëÜ Braille: ${livro.id_braille ? "Sim" : "N√£o"}\n\n`;
  resposta += `üìñ EPUB: ${livro.id_epub ? "Sim" : "N√£o"}\n`;
  
  return resposta;
}

function listarLivrosDisponiveis(livros) {
  if (livros.length === 0) {
    return "üìö No momento n√£o temos livros dispon√≠veis em nosso acervo.";
  }

  // Seleciona 3 livros aleat√≥rios para exemplificar
  const livrosExemplo = getRandomBooks(livros, 3);
  const exemplos = livrosExemplo.map(l => formatarTitulo(l.titulo)).join(", ");
  
  return `üìö Temos ${livros.length} livros dispon√≠veis em nosso acervo. Alguns exemplos: ${exemplos}.`;
}

function generateBookRecommendation(livros) {
  if (livros.length === 0) {
    return "üìö No momento n√£o temos livros dispon√≠veis para recomendar.";
  }

  const livroRecomendado = getRandomBooks(livros, 1)[0];
  return generateBookFullInfoResponse(livroRecomendado);
}

function generateBookFullInfoResponse(livro) {
  if (!livro) {
    return "üìö N√£o encontrei informa√ß√µes sobre este livro.";
  }

  let resposta = `üìñ **${formatarTitulo(livro.titulo)}**`;
  
  if (livro.subtitulo) {
    resposta += `\nüîπ Subt√≠tulo: ${livro.subtitulo}`;
  }
  
  if (livro.autor) {
    resposta += `\n‚úçÔ∏è Autor: ${formatarNomeAutor(livro.autor)}`;
  }
  
  if (livro.notaMedia && livro.notaMedia > 0) {
    resposta += `\n‚≠ê Avalia√ß√£o: ${formatarNota(livro.notaMedia)}`;
  }
  
  if (livro.descricao) {
    resposta += `\n\nüìù Descri√ß√£o: ${livro.descricao.substring(0, 200)}...`;
  }
  
  // Informa√ß√µes sobre formatos
  resposta += `\n\nüìö Formatos dispon√≠veis:`;
  resposta += `\nüì± E-book: ${livro.id_ebook ? "Sim" : "N√£o"}\n\n`;
  resposta += `\nüéß Audiobook: ${livro.id_Audiobook ? "Sim" : "N√£o"}\n\n`;
  resposta += `\nüëÜ Braille: ${livro.id_braille ? "Sim" : "N√£o"}\n\n`;
   resposta += `üìñ EPUB: ${livro.id_epub ? "Sim" : "N√£o"}\n\n`;

  return resposta;
}

// --- Fun√ß√µes auxiliares --- //

function isInteracaoSocial(texto) {
  const padroes = [
    /bom\s(dia|tarde|noite)/i,
    /ol√°|oi|opa|eae|ea√≠|sauda√ß√µes|hello|hi/i,
    /tudo\s(bem|contigo|com voc√™)/i,
    /como\s(vai|voc√™ est√°)/i,
    /qual\s√©\s(a boa|a novidade)/i,
    /(conte|diga)\s(uma|alguma)\s(coisa|informa√ß√£o)/i,
    /(qual|como)\s(√©|s√£o)\s(seu|seus)/i,
    /(quem|o que)\s(voc√™)\s(√©|faz)/i,
    /(fale|conte)\s(mais|sobre)/i,
    /(obrigado|valeu|agrade√ßo)/i
  ];
  return padroes.some(padrao => padrao.test(texto));
}

function gerarRespostaSocial(pergunta) {
  const respostas = {
    "bom dia": [
      "üìö Bom dia! Eu sou o LOOM, assistente da Livraria Libra. Como posso te ajudar hoje? üòä",
      "üåû Bom dia! Pronto para descobrir novas leituras? Eu sou o LOOM, seu assistente liter√°rio!"
    ],
    "bom tarde": [
      "üìñ Boa tarde! Aqui √© o LOOM da Livraria Libra. Em que posso ajudar?",
      "‚òï Boa tarde! Alguma leitura em mente ou quer recomenda√ß√µes?"
    ],
    "bom noite": [
      "üåô Boa noite! Eu sou o LOOM, assistente noturno da Livraria Libra. Como posso ajudar?",
      "üìö Boa noite! Preparando sua lista de leitura para amanh√£?"
    ],
    "ol√°": [
      "üòä Ol√°! Eu sou o LOOM, seu assistente de livros. O que vamos explorar hoje?",
      "üìö Oi! Bem-vindo √† Livraria Libra. Como posso ajudar?"
    ],
    "oi": [
      "üåü Oi! Eu sou o LOOM, mascote digital da Livraria Libra. Pronto para novas aventuras liter√°rias?",
      "üìñ Oi! Qual ser√° sua pr√≥xima leitura? Estou aqui para ajudar!"
    ],
    "opa": [
      "üòä Opa! Tudo bem? Eu sou o LOOM, assistente da Livraria Libra. Bora falar de livros?",
      "üìö Opa! Eu sou o LOOM. Qual livro voc√™ est√° procurando hoje?"
    ],
    "tudo bem": [
      "üòä Tudo √≥timo, obrigado por perguntar! E com voc√™? Como posso ajudar hoje?",
      "üìö Estou muito bem, sempre pronto para ajudar com seu pr√≥ximo livro! E voc√™, tudo bem?"
    ],
    "como vai": [
      "üåü Estou √≥timo, cheio de energia para te ajudar a encontrar os melhores livros! E voc√™?",
      "üìñ Vou muito bem, obrigado! Aqui no mundo dos livros sempre tem algo novo. E com voc√™?"
    ],
    "obrigado": [
      "üòä De nada! Estou aqui para ajudar sempre que precisar!",
      "üìö Fico feliz em ajudar! Mais alguma coisa sobre livros?"
    ],
    "valeu": [
      "üëç Valeu voc√™ por usar nosso servi√ßo! Precisa de mais alguma coisa?",
      "üòä Que isso, estamos aqui para isso mesmo! Mais alguma d√∫vida liter√°ria?"
    ],
    "quem √© voc√™": [
      "üìö Eu sou o LOOM, o assistente virtual da Livraria Libra! Estou aqui para te ajudar a encontrar os melhores livros e informa√ß√µes liter√°rias!",
      "üòä Eu sou o LOOM, seu assistente de livros digital! Posso te ajudar a encontrar obras, autores e curiosidades do mundo liter√°rio!"
    ]
  };

  for (const [key, options] of Object.entries(respostas)) {
    if (pergunta.includes(key)) {
      return options[Math.floor(Math.random() * options.length)];
    }
  }

  return "üòä Ol√°! Eu sou o LOOM, assistente da Livraria Libra. Como posso te ajudar hoje?";
}

function generateCacheKey(pergunta, livros) {
  return `${pergunta.toLowerCase().trim()}-${livros.length}`;
}

function getFromCache(key) {
  const cached = responseCache.get(key);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.response;
  }
  return null;
}

function saveToCache(key, response) {
  responseCache.set(key, {
    response,
    timestamp: Date.now()
  });
}

function tryWithTimeout(promiseFn, timeout) {
  return Promise.race([
    promiseFn(),
    new Promise((_, reject) => 
      setTimeout(() => reject(new Error("Timeout exceeded")), timeout)
    )
  ]);
}

async function callHuggingFaceAPI(pergunta, livros) {
  const prompt = generatePrompt(pergunta, livros);
  
  const response = await fetch(
    "https://api-inference.huggingface.co/models/mistralai/Mixtral-8x7B-Instruct-v0.1",
    {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${process.env.HF_API_KEY}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        inputs: prompt,
        parameters: {
          max_new_tokens: 200,
          temperature: 0.7,
          top_p: 0.9,
          repetition_penalty: 1.1
        }
      })
    }
  );

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  const result = await response.json();
  return processResponse(result[0]?.generated_text || "", livros);
}

async function callTogetherAPI(pergunta, livros) {
  const prompt = generatePrompt(pergunta, livros);
  
  const response = await fetch("https://api.together.xyz/v1/completions", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${process.env.TOGETHER_API_KEY}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      model: "mistralai/Mixtral-8x7B-Instruct-v0.1",
      prompt: prompt,
      max_tokens: 200,
      temperature: 0.7,
      top_p: 0.9
    })
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  const result = await response.json();
  return processResponse(result.choices[0]?.text || "", livros);
}

async function callOllamaAPI(pergunta, livros) {
  const prompt = generatePrompt(pergunta, livros);
  
  const response = await fetch("http://localhost:11434/api/generate", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      model: "mistral",
      prompt: prompt,
      stream: false,
      options: {
        temperature: 0.7,
        num_predict: 200
      }
    })
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  const result = await response.json();
  return processResponse(result.response || "", livros);
}

function generateLocalResponse(perguntaLower, livros) {
  // Verifica se √© pedido de listar autores
  if (perguntaLower.includes("autores disponiveis") || 
      perguntaLower.includes("autores dispon√≠veis") ||
      perguntaLower.includes("quais autores")) {
    return listarAutoresDisponiveis(livros);
  }

  // Verifica se √© pedido de livro de um autor espec√≠fico
  const matchAutor = perguntaLower.match(/(?:livro|obra|livros) (?:do|de|da) ([^?]+)/);
  if (matchAutor) {
    const autorBuscado = matchAutor[1].trim();
    const livrosDoAutor = findBooksByAuthor(autorBuscado, livros);
    
    if (livrosDoAutor.length > 0) {
      contextoConversa.ultimoLivroMencionado = livrosDoAutor[0];
      return generateAuthorResponse(livrosDoAutor);
    }
  }

  // Restante da l√≥gica original
  const livroEncontrado = findBook(perguntaLower, livros);
  if (livroEncontrado) {
    contextoConversa.ultimoLivroMencionado = livroEncontrado;
    return generateBookFoundResponse(livroEncontrado);
  }
  
  const livrosGenero = findBooksByGenre(perguntaLower, livros);
  if (livrosGenero.length > 0) {
    return generateGenreResponse(livrosGenero);
  }
  
  return "üìö N√£o entendi sua pergunta. Poderia reformular?";
}

function listarAutoresDisponiveis(livros) {
  const autores = new Set();
  
  livros.forEach(livro => {
    if (livro.autor) {
      const autorFormatado = formatarNomeAutor(livro.autor);
      autores.add(autorFormatado);
    }
  });

  if (autores.size === 0) {
    return "No momento n√£o temos autores cadastrados em nosso acervo.";
  }

  const listaAutores = Array.from(autores).sort();
  return `Claro! Atualmente, temos os seguintes autores dispon√≠veis em nossa livraria: ${listaAutores.join(', ')}. üòä`;
}

function formatarNomeAutor(nome) {
  if (!nome) return 'Autor desconhecido';
  
  return nome.trim()
    .split(' ')
    .map(parte => {
      if (/^[A-Z]\.([A-Z]\.)?$/.test(parte)) {
        return parte;
      }
      return parte.charAt(0).toUpperCase() + parte.slice(1).toLowerCase();
    })
    .join(' ');
}

function findBooksByAuthor(pergunta, livros) {
  let autorBuscado = pergunta.toLowerCase();
  
  const termosRemover = ["livro", "livros", "obra", "obras", "do", "da", "de"];
  termosRemover.forEach(termo => {
    autorBuscado = autorBuscado.replace(termo, '').trim();
  });

  return livros.filter(livro => {
    if (!livro.autor) return false;
    
    const autorLower = livro.autor.toLowerCase();
    return autorLower.includes(autorBuscado) || autorBuscado.includes(autorLower);
  });
}

function generateAuthorResponse(livros) {
  if (livros.length === 0) {
    return "üìö N√£o encontrei livros deste autor em nosso acervo.";
  }

  const autor = formatarNomeAutor(livros[0].autor);
  const livrosList = livros.slice(0, 5)
    .map(l => `‚Ä¢ "${formatarTitulo(l.titulo)}"` + (l.notaMedia ? ` ${formatarNota(l.notaMedia)}` : ''))
    .join('\n');
  
  return `‚úçÔ∏è Obras de ${autor} dispon√≠veis:\n${livrosList}\n\nDeseja informa√ß√µes sobre algum espec√≠fico? üòä`;
}

function formatarTitulo(titulo) {
  if (!titulo) return 'T√≠tulo desconhecido';
  
  const palavrasMinusculas = ['de', 'da', 'do', 'das', 'dos', 'e', 'em', 'na', 'no', 'para'];
  
  return titulo.toLowerCase()
    .split(' ')
    .map((palavra, index) => {
      if (index > 0 && palavrasMinusculas.includes(palavra)) {
        return palavra;
      }
      return palavra.charAt(0).toUpperCase() + palavra.slice(1);
    })
    .join(' ');
}

function findBook(pergunta, livros) {
  const match = pergunta.match(/"([^"]+)"/) || pergunta.match(/(?:livro|obra)\s+([^?]+)/) || [null, pergunta];
  const termoBusca = match[1] ? match[1].trim().toLowerCase() : pergunta.toLowerCase();
  
  return livros.find(livro => {
    if (!livro.titulo) return false;
    
    const tituloLower = livro.titulo.toLowerCase();
    return tituloLower.includes(termoBusca) || termoBusca.includes(tituloLower);
  });
}

function generateBookFoundResponse(livro) {
  if (!livro) {
    return "üìö N√£o encontrei esse livro em nosso acervo no momento.";
  }

  let resposta = `üìñ **${formatarTitulo(livro.titulo)}**`;
  
  if (livro.autor) {
    resposta += `\n‚úçÔ∏è Autor: ${formatarNomeAutor(livro.autor)}`;
  }
  
  if (livro.descricao) {
    resposta += `\n\nüìù ${livro.descricao.substring(0, 150)}...`;
  }
  
  if (livro.notaMedia && livro.notaMedia > 0) {
    resposta += `\n‚≠ê Avalia√ß√£o: ${formatarNota(livro.notaMedia)}`;
  }

  return resposta;
}

function findBooksByGenre(pergunta, livros) {
  const genero = livros.flatMap(l => l.generos || [])
    .find(g => g && pergunta.includes(g.toLowerCase()));
  
  return genero ? livros.filter(l => 
    (l.generos || []).some(g => g && g.toLowerCase() === genero.toLowerCase())
  ) : [];
}

function generateGenreResponse(livros) {
  const genero = livros[0].generos.find(Boolean);
  const livrosList = livros
    .map(l => `‚Ä¢ "${formatarTitulo(l.titulo)}" - ${formatarNomeAutor(l.autor)}`)
    .join('\n');
  
  return `üìö Livros de ${genero}:\n${livrosList}`;
}

function getRandomBooks(livros, count) {
  if (!livros || livros.length === 0) return [];
  const countSafe = Math.min(count, livros.length);
  return [...livros]
    .sort(() => 0.5 - Math.random())
    .slice(0, countSafe);
}

function formatarNota(nota) {
  if (!nota || nota === 0) return 'Sem avalia√ß√µes';
  const estrelas = '‚≠ê'.repeat(Math.round(nota));
  return `${estrelas} (${nota.toFixed(1)})`;
}

function generatePrompt(pergunta, livros = []) {
  const livrosValidos = livros.filter(l => l.titulo && l.autor);
  const sampleBooks = livrosValidos
    .map(l => `- "${l.titulo}" (${l.autor})`)
    .join('\n');

  return `[INST] Voc√™ √© o LOOM, assistente virtual da Livraria Libra. 

REGRAS:
1. Responda em PORTUGU√äS BRASILEIRO
2. Seja amig√°vel e prestativo
3. N√£o inclua links ou refer√™ncias a p√°ginas
4. Para perguntas sobre livros dispon√≠veis, mostre apenas a quantidade e 3 exemplos
5. Para recomenda√ß√µes, mostre informa√ß√µes completas de um livro aleat√≥rio
6. Formato para recomenda√ß√µes:
   üìñ T√≠tulo
   üîπ Subt√≠tulo (se existir)
   ‚úçÔ∏è Autor
   ‚≠ê Avalia√ß√£o
   üìù Descri√ß√£o resumida
   üìö Formatos dispon√≠veis (E-book e Audiobook)

LIVROS DISPON√çVEIS (${livrosValidos.length}):
${sampleBooks || 'Nenhum livro dispon√≠vel no momento'}

PERGUNTA: "${pergunta}"

RESPONDA APENAS COM INFORMA√á√ïES TEXTUAIS SOBRE OS LIVROS: [/INST]`;
}

function processResponse(rawResponse, livros) {
  let resposta = rawResponse.split("[/INST]")[1]?.trim() || rawResponse.trim();
  
  // Remove qualquer tentativa de link que possa ter sido gerada
  resposta = resposta.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1');
  
  if (!isRespostaValida(resposta)) {
    return "üòä Desculpe, n√£o entendi completamente. Poderia reformular?";
  }
  
  if (!resposta.match(/[\u{1F600}-\u{1F6FF}]/u)) {
    resposta = "üìö " + resposta;
  }
  
  return resposta;
}

function isRespostaValida(resposta) {
  if (!resposta || resposta.length < 3) return false;
  
  const respostasInvalidas = [
    "n√£o entendi",
    "n√£o encontrei",
    "n√£o sei",
    "n√£o consegui"
  ];
  
  return !respostasInvalidas.some(invalida => 
    resposta.toLowerCase().includes(invalida)
  );
}

module.exports = perguntarIA;